// Code generated by protoc-gen-go.
// source: build/remote/remote_protocol.proto
// DO NOT EDIT!

/*
Package build_remote is a generated protocol buffer package.

It is generated from these files:
	build/remote/remote_protocol.proto

It has these top-level messages:
	ContentDigest
	FileMetadata
	Platform
	Action
	Command
	Output
	ActionResult
	CasStatus
	FileNode
	CasLookupRequest
	CasLookupReply
	CasUploadTreeMetadataRequest
	CasUploadTreeMetadataReply
	CasDownloadTreeMetadataRequest
	CasDownloadTreeMetadataReply
	BlobChunk
	CasUploadBlobRequest
	CasUploadBlobReply
	CasDownloadTreeRequest
	CasDownloadReply
	CasDownloadBlobRequest
	ExecutionCacheRequest
	ExecutionCacheStatus
	ExecutionCacheReply
	ExecutionCacheSetRequest
	ExecutionCacheSetReply
	ExecuteRequest
	BuildInfo
	ExecutionStats
	ExecuteReply
	ExecutionStatus
*/
package build_remote

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// or not.
type CasStatus_ErrorCode int32

const (
	CasStatus_UNKNOWN          CasStatus_ErrorCode = 0
	CasStatus_INVALID_ARGUMENT CasStatus_ErrorCode = 1
	// have more information.
	CasStatus_MISSING_DIGEST  CasStatus_ErrorCode = 2
	CasStatus_DIGEST_MISMATCH CasStatus_ErrorCode = 3
	// match the server side computed one.
	CasStatus_NODE_PARSE_ERROR CasStatus_ErrorCode = 4
)

var CasStatus_ErrorCode_name = map[int32]string{
	0: "UNKNOWN",
	1: "INVALID_ARGUMENT",
	2: "MISSING_DIGEST",
	3: "DIGEST_MISMATCH",
	4: "NODE_PARSE_ERROR",
}
var CasStatus_ErrorCode_value = map[string]int32{
	"UNKNOWN":          0,
	"INVALID_ARGUMENT": 1,
	"MISSING_DIGEST":   2,
	"DIGEST_MISMATCH":  3,
	"NODE_PARSE_ERROR": 4,
}

func (x CasStatus_ErrorCode) String() string {
	return proto.EnumName(CasStatus_ErrorCode_name, int32(x))
}
func (CasStatus_ErrorCode) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{7, 0} }

type ExecutionCacheStatus_ErrorCode int32

const (
	ExecutionCacheStatus_UNKNOWN        ExecutionCacheStatus_ErrorCode = 0
	ExecutionCacheStatus_MISSING_RESULT ExecutionCacheStatus_ErrorCode = 1
	ExecutionCacheStatus_UNSUPPORTED    ExecutionCacheStatus_ErrorCode = 2
)

var ExecutionCacheStatus_ErrorCode_name = map[int32]string{
	0: "UNKNOWN",
	1: "MISSING_RESULT",
	2: "UNSUPPORTED",
}
var ExecutionCacheStatus_ErrorCode_value = map[string]int32{
	"UNKNOWN":        0,
	"MISSING_RESULT": 1,
	"UNSUPPORTED":    2,
}

func (x ExecutionCacheStatus_ErrorCode) String() string {
	return proto.EnumName(ExecutionCacheStatus_ErrorCode_name, int32(x))
}
func (ExecutionCacheStatus_ErrorCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{22, 0}
}

type ExecutionStatus_ErrorCode int32

const (
	ExecutionStatus_UNKNOWN_ERROR     ExecutionStatus_ErrorCode = 0
	ExecutionStatus_MISSING_COMMAND   ExecutionStatus_ErrorCode = 1
	ExecutionStatus_MISSING_INPUT     ExecutionStatus_ErrorCode = 2
	ExecutionStatus_DEADLINE_EXCEEDED ExecutionStatus_ErrorCode = 3
	ExecutionStatus_EXEC_FAILED       ExecutionStatus_ErrorCode = 4
)

var ExecutionStatus_ErrorCode_name = map[int32]string{
	0: "UNKNOWN_ERROR",
	1: "MISSING_COMMAND",
	2: "MISSING_INPUT",
	3: "DEADLINE_EXCEEDED",
	4: "EXEC_FAILED",
}
var ExecutionStatus_ErrorCode_value = map[string]int32{
	"UNKNOWN_ERROR":     0,
	"MISSING_COMMAND":   1,
	"MISSING_INPUT":     2,
	"DEADLINE_EXCEEDED": 3,
	"EXEC_FAILED":       4,
}

func (x ExecutionStatus_ErrorCode) String() string {
	return proto.EnumName(ExecutionStatus_ErrorCode_name, int32(x))
}
func (ExecutionStatus_ErrorCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{30, 0}
}

// These fields allow returning streaming statuses for the action progress.
type ExecutionStatus_ActionStage int32

const (
	ExecutionStatus_UNKNOWN_STAGE ExecutionStatus_ActionStage = 0
	ExecutionStatus_QUEUED        ExecutionStatus_ActionStage = 1
	ExecutionStatus_EXECUTING     ExecutionStatus_ActionStage = 2
	ExecutionStatus_FINISHED      ExecutionStatus_ActionStage = 3
)

var ExecutionStatus_ActionStage_name = map[int32]string{
	0: "UNKNOWN_STAGE",
	1: "QUEUED",
	2: "EXECUTING",
	3: "FINISHED",
}
var ExecutionStatus_ActionStage_value = map[string]int32{
	"UNKNOWN_STAGE": 0,
	"QUEUED":        1,
	"EXECUTING":     2,
	"FINISHED":      3,
}

func (x ExecutionStatus_ActionStage) String() string {
	return proto.EnumName(ExecutionStatus_ActionStage_name, int32(x))
}
func (ExecutionStatus_ActionStage) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{30, 1}
}

type ContentDigest struct {
	Digest []byte `protobuf:"bytes,1,opt,name=digest,proto3" json:"digest,omitempty"`
	// (see below). The contents are digested using SHA1 (20 bytes).
	SizeBytes int64 `protobuf:"varint,2,opt,name=size_bytes,json=sizeBytes" json:"size_bytes,omitempty"`
	Version   int32 `protobuf:"varint,3,opt,name=version" json:"version,omitempty"`
}

func (m *ContentDigest) Reset()                    { *m = ContentDigest{} }
func (m *ContentDigest) String() string            { return proto.CompactTextString(m) }
func (*ContentDigest) ProtoMessage()               {}
func (*ContentDigest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *ContentDigest) GetDigest() []byte {
	if m != nil {
		return m.Digest
	}
	return nil
}

func (m *ContentDigest) GetSizeBytes() int64 {
	if m != nil {
		return m.SizeBytes
	}
	return 0
}

func (m *ContentDigest) GetVersion() int32 {
	if m != nil {
		return m.Version
	}
	return 0
}

type FileMetadata struct {
	Digest     *ContentDigest `protobuf:"bytes,1,opt,name=digest" json:"digest,omitempty"`
	Executable bool           `protobuf:"varint,3,opt,name=executable" json:"executable,omitempty"`
}

func (m *FileMetadata) Reset()                    { *m = FileMetadata{} }
func (m *FileMetadata) String() string            { return proto.CompactTextString(m) }
func (*FileMetadata) ProtoMessage()               {}
func (*FileMetadata) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *FileMetadata) GetDigest() *ContentDigest {
	if m != nil {
		return m.Digest
	}
	return nil
}

func (m *FileMetadata) GetExecutable() bool {
	if m != nil {
		return m.Executable
	}
	return false
}

type Platform struct {
}

func (m *Platform) Reset()                    { *m = Platform{} }
func (m *Platform) String() string            { return proto.CompactTextString(m) }
func (*Platform) ProtoMessage()               {}
func (*Platform) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

// All the fields of this message have the following in common: they are
// expected to define a result. All instructions to remote execution that do
// not affect the result should be out of this message, because this message
// will be used as the Execution Cache key.
type Action struct {
	// The digest of the command (as an encoded proto blob).
	// Digested separately, because it is both long and reusable.
	CommandDigest *ContentDigest `protobuf:"bytes,1,opt,name=command_digest,json=commandDigest" json:"command_digest,omitempty"`
	// The Merkle digest of the root input directory.
	InputRootDigest *ContentDigest `protobuf:"bytes,2,opt,name=input_root_digest,json=inputRootDigest" json:"input_root_digest,omitempty"`
	// Relative paths to the action's output files and directories.
	// The standard output and error stream contents are always returned
	// in addition (see ActionResult message).
	// Any unnamed output files will be discarded.
	// A path will be interpreted as a directory iff it contains a trailing
	// slash.
	// This should be sorted!
	OutputPath []string  `protobuf:"bytes,4,rep,name=output_path,json=outputPath" json:"output_path,omitempty"`
	Platform   *Platform `protobuf:"bytes,5,opt,name=platform" json:"platform,omitempty"`
}

func (m *Action) Reset()                    { *m = Action{} }
func (m *Action) String() string            { return proto.CompactTextString(m) }
func (*Action) ProtoMessage()               {}
func (*Action) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *Action) GetCommandDigest() *ContentDigest {
	if m != nil {
		return m.CommandDigest
	}
	return nil
}

func (m *Action) GetInputRootDigest() *ContentDigest {
	if m != nil {
		return m.InputRootDigest
	}
	return nil
}

func (m *Action) GetOutputPath() []string {
	if m != nil {
		return m.OutputPath
	}
	return nil
}

func (m *Action) GetPlatform() *Platform {
	if m != nil {
		return m.Platform
	}
	return nil
}

type Command struct {
	// The argument vector.  argv[0] is the binary.
	Argv []string `protobuf:"bytes,1,rep,name=argv" json:"argv,omitempty"`
	// Environment variables, sorted by variable.
	Environment []*Command_EnvironmentEntry `protobuf:"bytes,2,rep,name=environment" json:"environment,omitempty"`
}

func (m *Command) Reset()                    { *m = Command{} }
func (m *Command) String() string            { return proto.CompactTextString(m) }
func (*Command) ProtoMessage()               {}
func (*Command) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *Command) GetArgv() []string {
	if m != nil {
		return m.Argv
	}
	return nil
}

func (m *Command) GetEnvironment() []*Command_EnvironmentEntry {
	if m != nil {
		return m.Environment
	}
	return nil
}

// A map of environment variables.
// This is part of the command rather than Platform, because it does not
// affect scheduling.
type Command_EnvironmentEntry struct {
	Variable string `protobuf:"bytes,1,opt,name=variable" json:"variable,omitempty"`
	Value    string `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
}

func (m *Command_EnvironmentEntry) Reset()                    { *m = Command_EnvironmentEntry{} }
func (m *Command_EnvironmentEntry) String() string            { return proto.CompactTextString(m) }
func (*Command_EnvironmentEntry) ProtoMessage()               {}
func (*Command_EnvironmentEntry) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4, 0} }

func (m *Command_EnvironmentEntry) GetVariable() string {
	if m != nil {
		return m.Variable
	}
	return ""
}

func (m *Command_EnvironmentEntry) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type Output struct {
	Path string `protobuf:"bytes,1,opt,name=path" json:"path,omitempty"`
	// Yes, we shouldn't have to repeat paths here, but it should not be too
	// costly, and might help.
	// The actual output bodies will be stored in CAS.
	//
	// Types that are valid to be assigned to Content:
	//	*Output_Digest
	//	*Output_FileMetadata
	Content isOutput_Content `protobuf_oneof:"content"`
}

func (m *Output) Reset()                    { *m = Output{} }
func (m *Output) String() string            { return proto.CompactTextString(m) }
func (*Output) ProtoMessage()               {}
func (*Output) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

type isOutput_Content interface {
	isOutput_Content()
}

type Output_Digest struct {
	Digest *ContentDigest `protobuf:"bytes,2,opt,name=digest,oneof"`
}
type Output_FileMetadata struct {
	FileMetadata *FileMetadata `protobuf:"bytes,3,opt,name=file_metadata,json=fileMetadata,oneof"`
}

func (*Output_Digest) isOutput_Content()       {}
func (*Output_FileMetadata) isOutput_Content() {}

func (m *Output) GetContent() isOutput_Content {
	if m != nil {
		return m.Content
	}
	return nil
}

func (m *Output) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *Output) GetDigest() *ContentDigest {
	if x, ok := m.GetContent().(*Output_Digest); ok {
		return x.Digest
	}
	return nil
}

func (m *Output) GetFileMetadata() *FileMetadata {
	if x, ok := m.GetContent().(*Output_FileMetadata); ok {
		return x.FileMetadata
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Output) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Output_OneofMarshaler, _Output_OneofUnmarshaler, _Output_OneofSizer, []interface{}{
		(*Output_Digest)(nil),
		(*Output_FileMetadata)(nil),
	}
}

func _Output_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Output)
	// content
	switch x := m.Content.(type) {
	case *Output_Digest:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Digest); err != nil {
			return err
		}
	case *Output_FileMetadata:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.FileMetadata); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Output.Content has unexpected type %T", x)
	}
	return nil
}

func _Output_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Output)
	switch tag {
	case 2: // content.digest
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ContentDigest)
		err := b.DecodeMessage(msg)
		m.Content = &Output_Digest{msg}
		return true, err
	case 3: // content.file_metadata
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FileMetadata)
		err := b.DecodeMessage(msg)
		m.Content = &Output_FileMetadata{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Output_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Output)
	// content
	switch x := m.Content.(type) {
	case *Output_Digest:
		s := proto.Size(x.Digest)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Output_FileMetadata:
		s := proto.Size(x.FileMetadata)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type ActionResult struct {
	// Relative paths to the action's output files and directories.
	// Any unnamed output files will be discarded.
	// A path will be interpreted as a directory iff it contains a trailing
	// slash.
	// This should be sorted by path.
	Output       []*Output      `protobuf:"bytes,1,rep,name=output" json:"output,omitempty"`
	ReturnCode   int32          `protobuf:"varint,2,opt,name=return_code,json=returnCode" json:"return_code,omitempty"`
	StdoutDigest *ContentDigest `protobuf:"bytes,3,opt,name=stdout_digest,json=stdoutDigest" json:"stdout_digest,omitempty"`
	StderrDigest *ContentDigest `protobuf:"bytes,4,opt,name=stderr_digest,json=stderrDigest" json:"stderr_digest,omitempty"`
}

func (m *ActionResult) Reset()                    { *m = ActionResult{} }
func (m *ActionResult) String() string            { return proto.CompactTextString(m) }
func (*ActionResult) ProtoMessage()               {}
func (*ActionResult) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *ActionResult) GetOutput() []*Output {
	if m != nil {
		return m.Output
	}
	return nil
}

func (m *ActionResult) GetReturnCode() int32 {
	if m != nil {
		return m.ReturnCode
	}
	return 0
}

func (m *ActionResult) GetStdoutDigest() *ContentDigest {
	if m != nil {
		return m.StdoutDigest
	}
	return nil
}

func (m *ActionResult) GetStderrDigest() *ContentDigest {
	if m != nil {
		return m.StderrDigest
	}
	return nil
}

// Status message shared by all CAS requests.
type CasStatus struct {
	Succeeded   bool                `protobuf:"varint,1,opt,name=succeeded" json:"succeeded,omitempty"`
	Error       CasStatus_ErrorCode `protobuf:"varint,2,opt,name=error,enum=build.remote.CasStatus_ErrorCode" json:"error,omitempty"`
	ErrorDetail string              `protobuf:"bytes,3,opt,name=error_detail,json=errorDetail" json:"error_detail,omitempty"`
	// These are a common part of the status for many CAS requests:
	MissingDigest     []*ContentDigest `protobuf:"bytes,4,rep,name=missing_digest,json=missingDigest" json:"missing_digest,omitempty"`
	ParseFailedDigest []*ContentDigest `protobuf:"bytes,5,rep,name=parse_failed_digest,json=parseFailedDigest" json:"parse_failed_digest,omitempty"`
}

func (m *CasStatus) Reset()                    { *m = CasStatus{} }
func (m *CasStatus) String() string            { return proto.CompactTextString(m) }
func (*CasStatus) ProtoMessage()               {}
func (*CasStatus) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *CasStatus) GetSucceeded() bool {
	if m != nil {
		return m.Succeeded
	}
	return false
}

func (m *CasStatus) GetError() CasStatus_ErrorCode {
	if m != nil {
		return m.Error
	}
	return CasStatus_UNKNOWN
}

func (m *CasStatus) GetErrorDetail() string {
	if m != nil {
		return m.ErrorDetail
	}
	return ""
}

func (m *CasStatus) GetMissingDigest() []*ContentDigest {
	if m != nil {
		return m.MissingDigest
	}
	return nil
}

func (m *CasStatus) GetParseFailedDigest() []*ContentDigest {
	if m != nil {
		return m.ParseFailedDigest
	}
	return nil
}

type FileNode struct {
	FileMetadata *FileMetadata `protobuf:"bytes,1,opt,name=file_metadata,json=fileMetadata" json:"file_metadata,omitempty"`
	// The children should be sorted by path, and not have equal subdirectory
	// prefixes.
	Child []*FileNode_Child `protobuf:"bytes,2,rep,name=child" json:"child,omitempty"`
}

func (m *FileNode) Reset()                    { *m = FileNode{} }
func (m *FileNode) String() string            { return proto.CompactTextString(m) }
func (*FileNode) ProtoMessage()               {}
func (*FileNode) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *FileNode) GetFileMetadata() *FileMetadata {
	if m != nil {
		return m.FileMetadata
	}
	return nil
}

func (m *FileNode) GetChild() []*FileNode_Child {
	if m != nil {
		return m.Child
	}
	return nil
}

type FileNode_Child struct {
	Path   string         `protobuf:"bytes,1,opt,name=path" json:"path,omitempty"`
	Digest *ContentDigest `protobuf:"bytes,2,opt,name=digest" json:"digest,omitempty"`
}

func (m *FileNode_Child) Reset()                    { *m = FileNode_Child{} }
func (m *FileNode_Child) String() string            { return proto.CompactTextString(m) }
func (*FileNode_Child) ProtoMessage()               {}
func (*FileNode_Child) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8, 0} }

func (m *FileNode_Child) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *FileNode_Child) GetDigest() *ContentDigest {
	if m != nil {
		return m.Digest
	}
	return nil
}

type CasLookupRequest struct {
	Digest []*ContentDigest `protobuf:"bytes,1,rep,name=digest" json:"digest,omitempty"`
}

func (m *CasLookupRequest) Reset()                    { *m = CasLookupRequest{} }
func (m *CasLookupRequest) String() string            { return proto.CompactTextString(m) }
func (*CasLookupRequest) ProtoMessage()               {}
func (*CasLookupRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *CasLookupRequest) GetDigest() []*ContentDigest {
	if m != nil {
		return m.Digest
	}
	return nil
}

type CasLookupReply struct {
	Status *CasStatus `protobuf:"bytes,1,opt,name=status" json:"status,omitempty"`
}

func (m *CasLookupReply) Reset()                    { *m = CasLookupReply{} }
func (m *CasLookupReply) String() string            { return proto.CompactTextString(m) }
func (*CasLookupReply) ProtoMessage()               {}
func (*CasLookupReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *CasLookupReply) GetStatus() *CasStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

type CasUploadTreeMetadataRequest struct {
	TreeNode []*FileNode `protobuf:"bytes,1,rep,name=tree_node,json=treeNode" json:"tree_node,omitempty"`
}

func (m *CasUploadTreeMetadataRequest) Reset()                    { *m = CasUploadTreeMetadataRequest{} }
func (m *CasUploadTreeMetadataRequest) String() string            { return proto.CompactTextString(m) }
func (*CasUploadTreeMetadataRequest) ProtoMessage()               {}
func (*CasUploadTreeMetadataRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *CasUploadTreeMetadataRequest) GetTreeNode() []*FileNode {
	if m != nil {
		return m.TreeNode
	}
	return nil
}

type CasUploadTreeMetadataReply struct {
	Status *CasStatus `protobuf:"bytes,1,opt,name=status" json:"status,omitempty"`
}

func (m *CasUploadTreeMetadataReply) Reset()                    { *m = CasUploadTreeMetadataReply{} }
func (m *CasUploadTreeMetadataReply) String() string            { return proto.CompactTextString(m) }
func (*CasUploadTreeMetadataReply) ProtoMessage()               {}
func (*CasUploadTreeMetadataReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *CasUploadTreeMetadataReply) GetStatus() *CasStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

type CasDownloadTreeMetadataRequest struct {
	Root *ContentDigest `protobuf:"bytes,1,opt,name=root" json:"root,omitempty"`
}

func (m *CasDownloadTreeMetadataRequest) Reset()                    { *m = CasDownloadTreeMetadataRequest{} }
func (m *CasDownloadTreeMetadataRequest) String() string            { return proto.CompactTextString(m) }
func (*CasDownloadTreeMetadataRequest) ProtoMessage()               {}
func (*CasDownloadTreeMetadataRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *CasDownloadTreeMetadataRequest) GetRoot() *ContentDigest {
	if m != nil {
		return m.Root
	}
	return nil
}

type CasDownloadTreeMetadataReply struct {
	Status   *CasStatus  `protobuf:"bytes,1,opt,name=status" json:"status,omitempty"`
	TreeNode []*FileNode `protobuf:"bytes,2,rep,name=tree_node,json=treeNode" json:"tree_node,omitempty"`
}

func (m *CasDownloadTreeMetadataReply) Reset()                    { *m = CasDownloadTreeMetadataReply{} }
func (m *CasDownloadTreeMetadataReply) String() string            { return proto.CompactTextString(m) }
func (*CasDownloadTreeMetadataReply) ProtoMessage()               {}
func (*CasDownloadTreeMetadataReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *CasDownloadTreeMetadataReply) GetStatus() *CasStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *CasDownloadTreeMetadataReply) GetTreeNode() []*FileNode {
	if m != nil {
		return m.TreeNode
	}
	return nil
}

type BlobChunk struct {
	Digest *ContentDigest `protobuf:"bytes,1,opt,name=digest" json:"digest,omitempty"`
	Offset int64          `protobuf:"varint,2,opt,name=offset" json:"offset,omitempty"`
	Data   []byte         `protobuf:"bytes,3,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *BlobChunk) Reset()                    { *m = BlobChunk{} }
func (m *BlobChunk) String() string            { return proto.CompactTextString(m) }
func (*BlobChunk) ProtoMessage()               {}
func (*BlobChunk) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *BlobChunk) GetDigest() *ContentDigest {
	if m != nil {
		return m.Digest
	}
	return nil
}

func (m *BlobChunk) GetOffset() int64 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *BlobChunk) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// This will be used for batching files/blobs.
type CasUploadBlobRequest struct {
	Data *BlobChunk `protobuf:"bytes,1,opt,name=data" json:"data,omitempty"`
}

func (m *CasUploadBlobRequest) Reset()                    { *m = CasUploadBlobRequest{} }
func (m *CasUploadBlobRequest) String() string            { return proto.CompactTextString(m) }
func (*CasUploadBlobRequest) ProtoMessage()               {}
func (*CasUploadBlobRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *CasUploadBlobRequest) GetData() *BlobChunk {
	if m != nil {
		return m.Data
	}
	return nil
}

type CasUploadBlobReply struct {
	Status *CasStatus `protobuf:"bytes,1,opt,name=status" json:"status,omitempty"`
}

func (m *CasUploadBlobReply) Reset()                    { *m = CasUploadBlobReply{} }
func (m *CasUploadBlobReply) String() string            { return proto.CompactTextString(m) }
func (*CasUploadBlobReply) ProtoMessage()               {}
func (*CasUploadBlobReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *CasUploadBlobReply) GetStatus() *CasStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

type CasDownloadTreeRequest struct {
	RootDigest *ContentDigest `protobuf:"bytes,1,opt,name=root_digest,json=rootDigest" json:"root_digest,omitempty"`
}

func (m *CasDownloadTreeRequest) Reset()                    { *m = CasDownloadTreeRequest{} }
func (m *CasDownloadTreeRequest) String() string            { return proto.CompactTextString(m) }
func (*CasDownloadTreeRequest) ProtoMessage()               {}
func (*CasDownloadTreeRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *CasDownloadTreeRequest) GetRootDigest() *ContentDigest {
	if m != nil {
		return m.RootDigest
	}
	return nil
}

// This message is streamed.
type CasDownloadReply struct {
	Status *CasStatus `protobuf:"bytes,1,opt,name=status" json:"status,omitempty"`
	Data   *BlobChunk `protobuf:"bytes,2,opt,name=data" json:"data,omitempty"`
}

func (m *CasDownloadReply) Reset()                    { *m = CasDownloadReply{} }
func (m *CasDownloadReply) String() string            { return proto.CompactTextString(m) }
func (*CasDownloadReply) ProtoMessage()               {}
func (*CasDownloadReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

func (m *CasDownloadReply) GetStatus() *CasStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *CasDownloadReply) GetData() *BlobChunk {
	if m != nil {
		return m.Data
	}
	return nil
}

type CasDownloadBlobRequest struct {
	Digest []*ContentDigest `protobuf:"bytes,1,rep,name=digest" json:"digest,omitempty"`
}

func (m *CasDownloadBlobRequest) Reset()                    { *m = CasDownloadBlobRequest{} }
func (m *CasDownloadBlobRequest) String() string            { return proto.CompactTextString(m) }
func (*CasDownloadBlobRequest) ProtoMessage()               {}
func (*CasDownloadBlobRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

func (m *CasDownloadBlobRequest) GetDigest() []*ContentDigest {
	if m != nil {
		return m.Digest
	}
	return nil
}

type ExecutionCacheRequest struct {
	ActionDigest *ContentDigest `protobuf:"bytes,1,opt,name=action_digest,json=actionDigest" json:"action_digest,omitempty"`
}

func (m *ExecutionCacheRequest) Reset()                    { *m = ExecutionCacheRequest{} }
func (m *ExecutionCacheRequest) String() string            { return proto.CompactTextString(m) }
func (*ExecutionCacheRequest) ProtoMessage()               {}
func (*ExecutionCacheRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21} }

func (m *ExecutionCacheRequest) GetActionDigest() *ContentDigest {
	if m != nil {
		return m.ActionDigest
	}
	return nil
}

type ExecutionCacheStatus struct {
	// Whether the request had any server side errors. For a lookup (get result)
	// request, a true value means the result was found in the cache.
	Succeeded   bool                           `protobuf:"varint,1,opt,name=succeeded" json:"succeeded,omitempty"`
	Error       ExecutionCacheStatus_ErrorCode `protobuf:"varint,2,opt,name=error,enum=build.remote.ExecutionCacheStatus_ErrorCode" json:"error,omitempty"`
	ErrorDetail string                         `protobuf:"bytes,3,opt,name=error_detail,json=errorDetail" json:"error_detail,omitempty"`
}

func (m *ExecutionCacheStatus) Reset()                    { *m = ExecutionCacheStatus{} }
func (m *ExecutionCacheStatus) String() string            { return proto.CompactTextString(m) }
func (*ExecutionCacheStatus) ProtoMessage()               {}
func (*ExecutionCacheStatus) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{22} }

func (m *ExecutionCacheStatus) GetSucceeded() bool {
	if m != nil {
		return m.Succeeded
	}
	return false
}

func (m *ExecutionCacheStatus) GetError() ExecutionCacheStatus_ErrorCode {
	if m != nil {
		return m.Error
	}
	return ExecutionCacheStatus_UNKNOWN
}

func (m *ExecutionCacheStatus) GetErrorDetail() string {
	if m != nil {
		return m.ErrorDetail
	}
	return ""
}

type ExecutionCacheReply struct {
	Status *ExecutionCacheStatus `protobuf:"bytes,1,opt,name=status" json:"status,omitempty"`
	Result *ActionResult         `protobuf:"bytes,2,opt,name=result" json:"result,omitempty"`
}

func (m *ExecutionCacheReply) Reset()                    { *m = ExecutionCacheReply{} }
func (m *ExecutionCacheReply) String() string            { return proto.CompactTextString(m) }
func (*ExecutionCacheReply) ProtoMessage()               {}
func (*ExecutionCacheReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{23} }

func (m *ExecutionCacheReply) GetStatus() *ExecutionCacheStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *ExecutionCacheReply) GetResult() *ActionResult {
	if m != nil {
		return m.Result
	}
	return nil
}

type ExecutionCacheSetRequest struct {
	ActionDigest *ContentDigest `protobuf:"bytes,1,opt,name=action_digest,json=actionDigest" json:"action_digest,omitempty"`
	Result       *ActionResult  `protobuf:"bytes,2,opt,name=result" json:"result,omitempty"`
}

func (m *ExecutionCacheSetRequest) Reset()                    { *m = ExecutionCacheSetRequest{} }
func (m *ExecutionCacheSetRequest) String() string            { return proto.CompactTextString(m) }
func (*ExecutionCacheSetRequest) ProtoMessage()               {}
func (*ExecutionCacheSetRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{24} }

func (m *ExecutionCacheSetRequest) GetActionDigest() *ContentDigest {
	if m != nil {
		return m.ActionDigest
	}
	return nil
}

func (m *ExecutionCacheSetRequest) GetResult() *ActionResult {
	if m != nil {
		return m.Result
	}
	return nil
}

type ExecutionCacheSetReply struct {
	Status *ExecutionCacheStatus `protobuf:"bytes,1,opt,name=status" json:"status,omitempty"`
}

func (m *ExecutionCacheSetReply) Reset()                    { *m = ExecutionCacheSetReply{} }
func (m *ExecutionCacheSetReply) String() string            { return proto.CompactTextString(m) }
func (*ExecutionCacheSetReply) ProtoMessage()               {}
func (*ExecutionCacheSetReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{25} }

func (m *ExecutionCacheSetReply) GetStatus() *ExecutionCacheStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

type ExecuteRequest struct {
	Action       *Action `protobuf:"bytes,1,opt,name=action" json:"action,omitempty"`
	AcceptCached bool    `protobuf:"varint,2,opt,name=accept_cached,json=acceptCached" json:"accept_cached,omitempty"`
	// Later will probably add previous attempt history, as it will be
	// useful for monitoring and probably scheduling as well.
	// These fields will be useful for scheduling, error reporting (e.g. disk
	// exceeded) and for log analysis.
	TotalInputFileCount int32 `protobuf:"varint,3,opt,name=total_input_file_count,json=totalInputFileCount" json:"total_input_file_count,omitempty"`
	TotalInputFileBytes int64 `protobuf:"varint,4,opt,name=total_input_file_bytes,json=totalInputFileBytes" json:"total_input_file_bytes,omitempty"`
	// Used for monitoring and scheduling.
	BuildInfo *BuildInfo `protobuf:"bytes,5,opt,name=build_info,json=buildInfo" json:"build_info,omitempty"`
	// Timeout milliseconds for running this action.
	TimeoutMillis int64 `protobuf:"varint,6,opt,name=timeout_millis,json=timeoutMillis" json:"timeout_millis,omitempty"`
}

func (m *ExecuteRequest) Reset()                    { *m = ExecuteRequest{} }
func (m *ExecuteRequest) String() string            { return proto.CompactTextString(m) }
func (*ExecuteRequest) ProtoMessage()               {}
func (*ExecuteRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{26} }

func (m *ExecuteRequest) GetAction() *Action {
	if m != nil {
		return m.Action
	}
	return nil
}

func (m *ExecuteRequest) GetAcceptCached() bool {
	if m != nil {
		return m.AcceptCached
	}
	return false
}

func (m *ExecuteRequest) GetTotalInputFileCount() int32 {
	if m != nil {
		return m.TotalInputFileCount
	}
	return 0
}

func (m *ExecuteRequest) GetTotalInputFileBytes() int64 {
	if m != nil {
		return m.TotalInputFileBytes
	}
	return 0
}

func (m *ExecuteRequest) GetBuildInfo() *BuildInfo {
	if m != nil {
		return m.BuildInfo
	}
	return nil
}

func (m *ExecuteRequest) GetTimeoutMillis() int64 {
	if m != nil {
		return m.TimeoutMillis
	}
	return 0
}

type BuildInfo struct {
	BuildId string `protobuf:"bytes,1,opt,name=build_id,json=buildId" json:"build_id,omitempty"`
}

func (m *BuildInfo) Reset()                    { *m = BuildInfo{} }
func (m *BuildInfo) String() string            { return proto.CompactTextString(m) }
func (*BuildInfo) ProtoMessage()               {}
func (*BuildInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{27} }

func (m *BuildInfo) GetBuildId() string {
	if m != nil {
		return m.BuildId
	}
	return ""
}

type ExecutionStats struct {
}

func (m *ExecutionStats) Reset()                    { *m = ExecutionStats{} }
func (m *ExecutionStats) String() string            { return proto.CompactTextString(m) }
func (*ExecutionStats) ProtoMessage()               {}
func (*ExecutionStats) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{28} }

type ExecuteReply struct {
	Status         *ExecutionStatus `protobuf:"bytes,1,opt,name=status" json:"status,omitempty"`
	Result         *ActionResult    `protobuf:"bytes,2,opt,name=result" json:"result,omitempty"`
	CachedResult   bool             `protobuf:"varint,3,opt,name=cached_result,json=cachedResult" json:"cached_result,omitempty"`
	ExecutionStats *ExecutionStats  `protobuf:"bytes,4,opt,name=execution_stats,json=executionStats" json:"execution_stats,omitempty"`
	CasError       *CasStatus       `protobuf:"bytes,5,opt,name=cas_error,json=casError" json:"cas_error,omitempty"`
}

func (m *ExecuteReply) Reset()                    { *m = ExecuteReply{} }
func (m *ExecuteReply) String() string            { return proto.CompactTextString(m) }
func (*ExecuteReply) ProtoMessage()               {}
func (*ExecuteReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{29} }

func (m *ExecuteReply) GetStatus() *ExecutionStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *ExecuteReply) GetResult() *ActionResult {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *ExecuteReply) GetCachedResult() bool {
	if m != nil {
		return m.CachedResult
	}
	return false
}

func (m *ExecuteReply) GetExecutionStats() *ExecutionStats {
	if m != nil {
		return m.ExecutionStats
	}
	return nil
}

func (m *ExecuteReply) GetCasError() *CasStatus {
	if m != nil {
		return m.CasError
	}
	return nil
}

type ExecutionStatus struct {
	Executed    bool                        `protobuf:"varint,1,opt,name=executed" json:"executed,omitempty"`
	Succeeded   bool                        `protobuf:"varint,2,opt,name=succeeded" json:"succeeded,omitempty"`
	Error       ExecutionStatus_ErrorCode   `protobuf:"varint,3,opt,name=error,enum=build.remote.ExecutionStatus_ErrorCode" json:"error,omitempty"`
	ErrorDetail string                      `protobuf:"bytes,4,opt,name=error_detail,json=errorDetail" json:"error_detail,omitempty"`
	Stage       ExecutionStatus_ActionStage `protobuf:"varint,5,opt,name=stage,enum=build.remote.ExecutionStatus_ActionStage" json:"stage,omitempty"`
}

func (m *ExecutionStatus) Reset()                    { *m = ExecutionStatus{} }
func (m *ExecutionStatus) String() string            { return proto.CompactTextString(m) }
func (*ExecutionStatus) ProtoMessage()               {}
func (*ExecutionStatus) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{30} }

func (m *ExecutionStatus) GetExecuted() bool {
	if m != nil {
		return m.Executed
	}
	return false
}

func (m *ExecutionStatus) GetSucceeded() bool {
	if m != nil {
		return m.Succeeded
	}
	return false
}

func (m *ExecutionStatus) GetError() ExecutionStatus_ErrorCode {
	if m != nil {
		return m.Error
	}
	return ExecutionStatus_UNKNOWN_ERROR
}

func (m *ExecutionStatus) GetErrorDetail() string {
	if m != nil {
		return m.ErrorDetail
	}
	return ""
}

func (m *ExecutionStatus) GetStage() ExecutionStatus_ActionStage {
	if m != nil {
		return m.Stage
	}
	return ExecutionStatus_UNKNOWN_STAGE
}

func init() {
	proto.RegisterType((*ContentDigest)(nil), "build.remote.ContentDigest")
	proto.RegisterType((*FileMetadata)(nil), "build.remote.FileMetadata")
	proto.RegisterType((*Platform)(nil), "build.remote.Platform")
	proto.RegisterType((*Action)(nil), "build.remote.Action")
	proto.RegisterType((*Command)(nil), "build.remote.Command")
	proto.RegisterType((*Command_EnvironmentEntry)(nil), "build.remote.Command.EnvironmentEntry")
	proto.RegisterType((*Output)(nil), "build.remote.Output")
	proto.RegisterType((*ActionResult)(nil), "build.remote.ActionResult")
	proto.RegisterType((*CasStatus)(nil), "build.remote.CasStatus")
	proto.RegisterType((*FileNode)(nil), "build.remote.FileNode")
	proto.RegisterType((*FileNode_Child)(nil), "build.remote.FileNode.Child")
	proto.RegisterType((*CasLookupRequest)(nil), "build.remote.CasLookupRequest")
	proto.RegisterType((*CasLookupReply)(nil), "build.remote.CasLookupReply")
	proto.RegisterType((*CasUploadTreeMetadataRequest)(nil), "build.remote.CasUploadTreeMetadataRequest")
	proto.RegisterType((*CasUploadTreeMetadataReply)(nil), "build.remote.CasUploadTreeMetadataReply")
	proto.RegisterType((*CasDownloadTreeMetadataRequest)(nil), "build.remote.CasDownloadTreeMetadataRequest")
	proto.RegisterType((*CasDownloadTreeMetadataReply)(nil), "build.remote.CasDownloadTreeMetadataReply")
	proto.RegisterType((*BlobChunk)(nil), "build.remote.BlobChunk")
	proto.RegisterType((*CasUploadBlobRequest)(nil), "build.remote.CasUploadBlobRequest")
	proto.RegisterType((*CasUploadBlobReply)(nil), "build.remote.CasUploadBlobReply")
	proto.RegisterType((*CasDownloadTreeRequest)(nil), "build.remote.CasDownloadTreeRequest")
	proto.RegisterType((*CasDownloadReply)(nil), "build.remote.CasDownloadReply")
	proto.RegisterType((*CasDownloadBlobRequest)(nil), "build.remote.CasDownloadBlobRequest")
	proto.RegisterType((*ExecutionCacheRequest)(nil), "build.remote.ExecutionCacheRequest")
	proto.RegisterType((*ExecutionCacheStatus)(nil), "build.remote.ExecutionCacheStatus")
	proto.RegisterType((*ExecutionCacheReply)(nil), "build.remote.ExecutionCacheReply")
	proto.RegisterType((*ExecutionCacheSetRequest)(nil), "build.remote.ExecutionCacheSetRequest")
	proto.RegisterType((*ExecutionCacheSetReply)(nil), "build.remote.ExecutionCacheSetReply")
	proto.RegisterType((*ExecuteRequest)(nil), "build.remote.ExecuteRequest")
	proto.RegisterType((*BuildInfo)(nil), "build.remote.BuildInfo")
	proto.RegisterType((*ExecutionStats)(nil), "build.remote.ExecutionStats")
	proto.RegisterType((*ExecuteReply)(nil), "build.remote.ExecuteReply")
	proto.RegisterType((*ExecutionStatus)(nil), "build.remote.ExecutionStatus")
	proto.RegisterEnum("build.remote.CasStatus_ErrorCode", CasStatus_ErrorCode_name, CasStatus_ErrorCode_value)
	proto.RegisterEnum("build.remote.ExecutionCacheStatus_ErrorCode", ExecutionCacheStatus_ErrorCode_name, ExecutionCacheStatus_ErrorCode_value)
	proto.RegisterEnum("build.remote.ExecutionStatus_ErrorCode", ExecutionStatus_ErrorCode_name, ExecutionStatus_ErrorCode_value)
	proto.RegisterEnum("build.remote.ExecutionStatus_ActionStage", ExecutionStatus_ActionStage_name, ExecutionStatus_ActionStage_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for CasService service

type CasServiceClient interface {
	// Looks up given content keys in CAS, and returns success when found.
	// The single returned status will have the potentially missing digests,
	// which need to be re-uploaded.
	Lookup(ctx context.Context, in *CasLookupRequest, opts ...grpc.CallOption) (*CasLookupReply, error)
	// Uploads a directory tree into CAS. Not streamed, because it is only tree
	// metadata.
	UploadTreeMetadata(ctx context.Context, in *CasUploadTreeMetadataRequest, opts ...grpc.CallOption) (*CasUploadTreeMetadataReply, error)
	// Uploads data blob(s) into CAS.
	UploadBlob(ctx context.Context, opts ...grpc.CallOption) (CasService_UploadBlobClient, error)
	// Downoads a directory tree metadata from CAS.
	DownloadTreeMetadata(ctx context.Context, in *CasDownloadTreeMetadataRequest, opts ...grpc.CallOption) (*CasDownloadTreeMetadataReply, error)
	// Downoads a directory tree from CAS. Returns the entire root directory.
	DownloadTree(ctx context.Context, in *CasDownloadTreeRequest, opts ...grpc.CallOption) (CasService_DownloadTreeClient, error)
	// Downoads data blob(s) from CAS, returns them.
	DownloadBlob(ctx context.Context, in *CasDownloadBlobRequest, opts ...grpc.CallOption) (CasService_DownloadBlobClient, error)
}

type casServiceClient struct {
	cc *grpc.ClientConn
}

func NewCasServiceClient(cc *grpc.ClientConn) CasServiceClient {
	return &casServiceClient{cc}
}

func (c *casServiceClient) Lookup(ctx context.Context, in *CasLookupRequest, opts ...grpc.CallOption) (*CasLookupReply, error) {
	out := new(CasLookupReply)
	err := grpc.Invoke(ctx, "/build.remote.CasService/Lookup", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *casServiceClient) UploadTreeMetadata(ctx context.Context, in *CasUploadTreeMetadataRequest, opts ...grpc.CallOption) (*CasUploadTreeMetadataReply, error) {
	out := new(CasUploadTreeMetadataReply)
	err := grpc.Invoke(ctx, "/build.remote.CasService/UploadTreeMetadata", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *casServiceClient) UploadBlob(ctx context.Context, opts ...grpc.CallOption) (CasService_UploadBlobClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_CasService_serviceDesc.Streams[0], c.cc, "/build.remote.CasService/UploadBlob", opts...)
	if err != nil {
		return nil, err
	}
	x := &casServiceUploadBlobClient{stream}
	return x, nil
}

type CasService_UploadBlobClient interface {
	Send(*CasUploadBlobRequest) error
	CloseAndRecv() (*CasUploadBlobReply, error)
	grpc.ClientStream
}

type casServiceUploadBlobClient struct {
	grpc.ClientStream
}

func (x *casServiceUploadBlobClient) Send(m *CasUploadBlobRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *casServiceUploadBlobClient) CloseAndRecv() (*CasUploadBlobReply, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(CasUploadBlobReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *casServiceClient) DownloadTreeMetadata(ctx context.Context, in *CasDownloadTreeMetadataRequest, opts ...grpc.CallOption) (*CasDownloadTreeMetadataReply, error) {
	out := new(CasDownloadTreeMetadataReply)
	err := grpc.Invoke(ctx, "/build.remote.CasService/DownloadTreeMetadata", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *casServiceClient) DownloadTree(ctx context.Context, in *CasDownloadTreeRequest, opts ...grpc.CallOption) (CasService_DownloadTreeClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_CasService_serviceDesc.Streams[1], c.cc, "/build.remote.CasService/DownloadTree", opts...)
	if err != nil {
		return nil, err
	}
	x := &casServiceDownloadTreeClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type CasService_DownloadTreeClient interface {
	Recv() (*CasDownloadReply, error)
	grpc.ClientStream
}

type casServiceDownloadTreeClient struct {
	grpc.ClientStream
}

func (x *casServiceDownloadTreeClient) Recv() (*CasDownloadReply, error) {
	m := new(CasDownloadReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *casServiceClient) DownloadBlob(ctx context.Context, in *CasDownloadBlobRequest, opts ...grpc.CallOption) (CasService_DownloadBlobClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_CasService_serviceDesc.Streams[2], c.cc, "/build.remote.CasService/DownloadBlob", opts...)
	if err != nil {
		return nil, err
	}
	x := &casServiceDownloadBlobClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type CasService_DownloadBlobClient interface {
	Recv() (*CasDownloadReply, error)
	grpc.ClientStream
}

type casServiceDownloadBlobClient struct {
	grpc.ClientStream
}

func (x *casServiceDownloadBlobClient) Recv() (*CasDownloadReply, error) {
	m := new(CasDownloadReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for CasService service

type CasServiceServer interface {
	// Looks up given content keys in CAS, and returns success when found.
	// The single returned status will have the potentially missing digests,
	// which need to be re-uploaded.
	Lookup(context.Context, *CasLookupRequest) (*CasLookupReply, error)
	// Uploads a directory tree into CAS. Not streamed, because it is only tree
	// metadata.
	UploadTreeMetadata(context.Context, *CasUploadTreeMetadataRequest) (*CasUploadTreeMetadataReply, error)
	// Uploads data blob(s) into CAS.
	UploadBlob(CasService_UploadBlobServer) error
	// Downoads a directory tree metadata from CAS.
	DownloadTreeMetadata(context.Context, *CasDownloadTreeMetadataRequest) (*CasDownloadTreeMetadataReply, error)
	// Downoads a directory tree from CAS. Returns the entire root directory.
	DownloadTree(*CasDownloadTreeRequest, CasService_DownloadTreeServer) error
	// Downoads data blob(s) from CAS, returns them.
	DownloadBlob(*CasDownloadBlobRequest, CasService_DownloadBlobServer) error
}

func RegisterCasServiceServer(s *grpc.Server, srv CasServiceServer) {
	s.RegisterService(&_CasService_serviceDesc, srv)
}

func _CasService_Lookup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CasLookupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CasServiceServer).Lookup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/build.remote.CasService/Lookup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CasServiceServer).Lookup(ctx, req.(*CasLookupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CasService_UploadTreeMetadata_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CasUploadTreeMetadataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CasServiceServer).UploadTreeMetadata(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/build.remote.CasService/UploadTreeMetadata",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CasServiceServer).UploadTreeMetadata(ctx, req.(*CasUploadTreeMetadataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CasService_UploadBlob_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(CasServiceServer).UploadBlob(&casServiceUploadBlobServer{stream})
}

type CasService_UploadBlobServer interface {
	SendAndClose(*CasUploadBlobReply) error
	Recv() (*CasUploadBlobRequest, error)
	grpc.ServerStream
}

type casServiceUploadBlobServer struct {
	grpc.ServerStream
}

func (x *casServiceUploadBlobServer) SendAndClose(m *CasUploadBlobReply) error {
	return x.ServerStream.SendMsg(m)
}

func (x *casServiceUploadBlobServer) Recv() (*CasUploadBlobRequest, error) {
	m := new(CasUploadBlobRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _CasService_DownloadTreeMetadata_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CasDownloadTreeMetadataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CasServiceServer).DownloadTreeMetadata(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/build.remote.CasService/DownloadTreeMetadata",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CasServiceServer).DownloadTreeMetadata(ctx, req.(*CasDownloadTreeMetadataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CasService_DownloadTree_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(CasDownloadTreeRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CasServiceServer).DownloadTree(m, &casServiceDownloadTreeServer{stream})
}

type CasService_DownloadTreeServer interface {
	Send(*CasDownloadReply) error
	grpc.ServerStream
}

type casServiceDownloadTreeServer struct {
	grpc.ServerStream
}

func (x *casServiceDownloadTreeServer) Send(m *CasDownloadReply) error {
	return x.ServerStream.SendMsg(m)
}

func _CasService_DownloadBlob_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(CasDownloadBlobRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CasServiceServer).DownloadBlob(m, &casServiceDownloadBlobServer{stream})
}

type CasService_DownloadBlobServer interface {
	Send(*CasDownloadReply) error
	grpc.ServerStream
}

type casServiceDownloadBlobServer struct {
	grpc.ServerStream
}

func (x *casServiceDownloadBlobServer) Send(m *CasDownloadReply) error {
	return x.ServerStream.SendMsg(m)
}

var _CasService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "build.remote.CasService",
	HandlerType: (*CasServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Lookup",
			Handler:    _CasService_Lookup_Handler,
		},
		{
			MethodName: "UploadTreeMetadata",
			Handler:    _CasService_UploadTreeMetadata_Handler,
		},
		{
			MethodName: "DownloadTreeMetadata",
			Handler:    _CasService_DownloadTreeMetadata_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "UploadBlob",
			Handler:       _CasService_UploadBlob_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "DownloadTree",
			Handler:       _CasService_DownloadTree_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "DownloadBlob",
			Handler:       _CasService_DownloadBlob_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "build/remote/remote_protocol.proto",
}

// Client API for ExecutionCacheService service

type ExecutionCacheServiceClient interface {
	// Gets results of a cached action.
	GetCachedResult(ctx context.Context, in *ExecutionCacheRequest, opts ...grpc.CallOption) (*ExecutionCacheReply, error)
	// Set results of a cached action. This requires reproducible builds on
	// connected machines!
	SetCachedResult(ctx context.Context, in *ExecutionCacheSetRequest, opts ...grpc.CallOption) (*ExecutionCacheSetReply, error)
}

type executionCacheServiceClient struct {
	cc *grpc.ClientConn
}

func NewExecutionCacheServiceClient(cc *grpc.ClientConn) ExecutionCacheServiceClient {
	return &executionCacheServiceClient{cc}
}

func (c *executionCacheServiceClient) GetCachedResult(ctx context.Context, in *ExecutionCacheRequest, opts ...grpc.CallOption) (*ExecutionCacheReply, error) {
	out := new(ExecutionCacheReply)
	err := grpc.Invoke(ctx, "/build.remote.ExecutionCacheService/GetCachedResult", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *executionCacheServiceClient) SetCachedResult(ctx context.Context, in *ExecutionCacheSetRequest, opts ...grpc.CallOption) (*ExecutionCacheSetReply, error) {
	out := new(ExecutionCacheSetReply)
	err := grpc.Invoke(ctx, "/build.remote.ExecutionCacheService/SetCachedResult", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for ExecutionCacheService service

type ExecutionCacheServiceServer interface {
	// Gets results of a cached action.
	GetCachedResult(context.Context, *ExecutionCacheRequest) (*ExecutionCacheReply, error)
	// Set results of a cached action. This requires reproducible builds on
	// connected machines!
	SetCachedResult(context.Context, *ExecutionCacheSetRequest) (*ExecutionCacheSetReply, error)
}

func RegisterExecutionCacheServiceServer(s *grpc.Server, srv ExecutionCacheServiceServer) {
	s.RegisterService(&_ExecutionCacheService_serviceDesc, srv)
}

func _ExecutionCacheService_GetCachedResult_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExecutionCacheRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExecutionCacheServiceServer).GetCachedResult(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/build.remote.ExecutionCacheService/GetCachedResult",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExecutionCacheServiceServer).GetCachedResult(ctx, req.(*ExecutionCacheRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExecutionCacheService_SetCachedResult_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExecutionCacheSetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExecutionCacheServiceServer).SetCachedResult(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/build.remote.ExecutionCacheService/SetCachedResult",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExecutionCacheServiceServer).SetCachedResult(ctx, req.(*ExecutionCacheSetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _ExecutionCacheService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "build.remote.ExecutionCacheService",
	HandlerType: (*ExecutionCacheServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetCachedResult",
			Handler:    _ExecutionCacheService_GetCachedResult_Handler,
		},
		{
			MethodName: "SetCachedResult",
			Handler:    _ExecutionCacheService_SetCachedResult_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "build/remote/remote_protocol.proto",
}

// Client API for ExecuteService service

type ExecuteServiceClient interface {
	// Executes an action remotely.
	Execute(ctx context.Context, in *ExecuteRequest, opts ...grpc.CallOption) (ExecuteService_ExecuteClient, error)
}

type executeServiceClient struct {
	cc *grpc.ClientConn
}

func NewExecuteServiceClient(cc *grpc.ClientConn) ExecuteServiceClient {
	return &executeServiceClient{cc}
}

func (c *executeServiceClient) Execute(ctx context.Context, in *ExecuteRequest, opts ...grpc.CallOption) (ExecuteService_ExecuteClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_ExecuteService_serviceDesc.Streams[0], c.cc, "/build.remote.ExecuteService/Execute", opts...)
	if err != nil {
		return nil, err
	}
	x := &executeServiceExecuteClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ExecuteService_ExecuteClient interface {
	Recv() (*ExecuteReply, error)
	grpc.ClientStream
}

type executeServiceExecuteClient struct {
	grpc.ClientStream
}

func (x *executeServiceExecuteClient) Recv() (*ExecuteReply, error) {
	m := new(ExecuteReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for ExecuteService service

type ExecuteServiceServer interface {
	// Executes an action remotely.
	Execute(*ExecuteRequest, ExecuteService_ExecuteServer) error
}

func RegisterExecuteServiceServer(s *grpc.Server, srv ExecuteServiceServer) {
	s.RegisterService(&_ExecuteService_serviceDesc, srv)
}

func _ExecuteService_Execute_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ExecuteRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ExecuteServiceServer).Execute(m, &executeServiceExecuteServer{stream})
}

type ExecuteService_ExecuteServer interface {
	Send(*ExecuteReply) error
	grpc.ServerStream
}

type executeServiceExecuteServer struct {
	grpc.ServerStream
}

func (x *executeServiceExecuteServer) Send(m *ExecuteReply) error {
	return x.ServerStream.SendMsg(m)
}

var _ExecuteService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "build.remote.ExecuteService",
	HandlerType: (*ExecuteServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Execute",
			Handler:       _ExecuteService_Execute_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "build/remote/remote_protocol.proto",
}

func init() { proto.RegisterFile("build/remote/remote_protocol.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 1734 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xac, 0x58, 0xcd, 0x73, 0xe3, 0x48,
	0x15, 0x8f, 0xfc, 0x15, 0xfb, 0xd9, 0x49, 0x3c, 0x3d, 0xd9, 0x60, 0x4c, 0x76, 0xc8, 0x68, 0x87,
	0x21, 0x2c, 0x53, 0x1e, 0xca, 0xc3, 0x42, 0x15, 0xc5, 0xd6, 0xae, 0x63, 0x6b, 0x1c, 0xd7, 0xc6,
	0x4e, 0xb6, 0x1d, 0x0f, 0xb3, 0xc5, 0x41, 0x28, 0x52, 0x27, 0x51, 0xad, 0xac, 0x36, 0x52, 0x3b,
	0x30, 0x9c, 0xd9, 0x3b, 0x77, 0x4e, 0x1c, 0xa9, 0x82, 0xff, 0x82, 0x7f, 0x80, 0x13, 0x55, 0xdc,
	0xb8, 0xf2, 0x57, 0x50, 0xfd, 0x21, 0x45, 0x56, 0xfc, 0xb5, 0x1e, 0x4e, 0xee, 0x6e, 0xbd, 0xcf,
	0xdf, 0x7b, 0xfd, 0xde, 0x6b, 0x83, 0x7e, 0x35, 0x75, 0x3d, 0xe7, 0x65, 0x40, 0xc6, 0x94, 0x11,
	0xf5, 0x63, 0x4e, 0x02, 0xca, 0xa8, 0x4d, 0xbd, 0x86, 0x58, 0xa0, 0x8a, 0xa0, 0x69, 0xc8, 0x8f,
	0xfa, 0x6f, 0x60, 0xa7, 0x4d, 0x7d, 0x46, 0x7c, 0xd6, 0x71, 0x6f, 0x48, 0xc8, 0xd0, 0x01, 0x14,
	0x1c, 0xb1, 0xaa, 0x69, 0x47, 0xda, 0x71, 0x05, 0xab, 0x1d, 0xfa, 0x10, 0x20, 0x74, 0xff, 0x40,
	0xcc, 0xab, 0x77, 0x8c, 0x84, 0xb5, 0xcc, 0x91, 0x76, 0x9c, 0xc5, 0x25, 0x7e, 0x72, 0xc2, 0x0f,
	0x50, 0x0d, 0xb6, 0xef, 0x48, 0x10, 0xba, 0xd4, 0xaf, 0x65, 0x8f, 0xb4, 0xe3, 0x3c, 0x8e, 0xb6,
	0xba, 0x0d, 0x95, 0xd7, 0xae, 0x47, 0xfa, 0x84, 0x59, 0x8e, 0xc5, 0x2c, 0xf4, 0x6a, 0x46, 0x41,
	0xb9, 0xf9, 0xbd, 0x46, 0xd2, 0xa0, 0xc6, 0x8c, 0x35, 0xb1, 0xf6, 0x27, 0x00, 0xe4, 0xf7, 0xc4,
	0x9e, 0x32, 0xeb, 0xca, 0x23, 0x42, 0x43, 0x11, 0x27, 0x4e, 0x74, 0x80, 0xe2, 0x85, 0x67, 0xb1,
	0x6b, 0x1a, 0x8c, 0xf5, 0xff, 0x6a, 0x50, 0x68, 0xd9, 0xcc, 0xa5, 0x3e, 0x3a, 0x81, 0x5d, 0x9b,
	0x8e, 0xc7, 0x96, 0xef, 0x98, 0xeb, 0xeb, 0xdc, 0x51, 0x2c, 0x0a, 0x90, 0x2e, 0x3c, 0x72, 0xfd,
	0xc9, 0x94, 0x99, 0x01, 0xa5, 0x2c, 0x12, 0x93, 0x59, 0x2d, 0x66, 0x4f, 0x70, 0x61, 0x4a, 0x23,
	0x64, 0xbf, 0x0f, 0x65, 0x3a, 0x65, 0x5c, 0xd2, 0xc4, 0x62, 0xb7, 0xb5, 0xdc, 0x51, 0xf6, 0xb8,
	0x84, 0x41, 0x1e, 0x5d, 0x58, 0xec, 0x16, 0x35, 0xa1, 0x38, 0x51, 0x4e, 0xd4, 0xf2, 0x42, 0xc1,
	0xc1, 0xac, 0x82, 0xc8, 0x45, 0x1c, 0xd3, 0xe9, 0x7f, 0xd7, 0x60, 0xbb, 0x2d, 0xed, 0x45, 0x08,
	0x72, 0x56, 0x70, 0x73, 0x57, 0xd3, 0x84, 0x64, 0xb1, 0x46, 0xa7, 0x50, 0x26, 0xfe, 0x9d, 0x1b,
	0x50, 0x7f, 0x4c, 0x7c, 0x6e, 0x77, 0xf6, 0xb8, 0xdc, 0x7c, 0x9e, 0xb6, 0x5b, 0xf0, 0x37, 0x8c,
	0x7b, 0x42, 0xc3, 0x67, 0xc1, 0x3b, 0x9c, 0x64, 0xad, 0x77, 0xa0, 0x9a, 0x26, 0x40, 0x75, 0x28,
	0xde, 0x59, 0x81, 0x2b, 0x82, 0xc2, 0x91, 0x2d, 0xe1, 0x78, 0x8f, 0xf6, 0x21, 0x7f, 0x67, 0x79,
	0x53, 0x22, 0xb0, 0x2a, 0x61, 0xb9, 0xd1, 0xff, 0xa2, 0x41, 0xe1, 0x5c, 0xb8, 0xcc, 0xcd, 0x15,
	0x40, 0x48, 0x46, 0xb1, 0x46, 0x9f, 0xc4, 0xc9, 0xb1, 0x1a, 0xe1, 0xd3, 0xad, 0x38, 0x3d, 0x5a,
	0xb0, 0x73, 0xed, 0x7a, 0xc4, 0x1c, 0xab, 0x24, 0x13, 0x19, 0x52, 0x6e, 0xd6, 0x67, 0xb9, 0x93,
	0x69, 0x78, 0xba, 0x85, 0x2b, 0xd7, 0x89, 0xfd, 0x49, 0x09, 0xb6, 0x6d, 0x29, 0x5d, 0xff, 0x8f,
	0x06, 0x15, 0x99, 0x40, 0x98, 0x84, 0x53, 0x8f, 0xa1, 0x17, 0x50, 0x90, 0x61, 0x12, 0xd0, 0x96,
	0x9b, 0xfb, 0xb3, 0x72, 0xa5, 0x3f, 0x58, 0xd1, 0xf0, 0x38, 0x07, 0x84, 0x4d, 0x03, 0xdf, 0xb4,
	0xa9, 0x23, 0xdd, 0xcf, 0x63, 0x90, 0x47, 0x6d, 0xea, 0x10, 0xf4, 0x39, 0xec, 0x84, 0xcc, 0xa1,
	0xd3, 0x38, 0x9b, 0xb2, 0xab, 0xb3, 0xa9, 0x22, 0x39, 0x54, 0x2a, 0x49, 0x09, 0x24, 0x08, 0x22,
	0x09, 0xb9, 0xf5, 0x24, 0x90, 0x20, 0x90, 0x3b, 0xfd, 0x9b, 0x2c, 0x94, 0xda, 0x56, 0x38, 0x64,
	0x16, 0x9b, 0x86, 0xe8, 0x10, 0x4a, 0xe1, 0xd4, 0xb6, 0x09, 0x71, 0x88, 0x23, 0xe2, 0x51, 0xc4,
	0xf7, 0x07, 0xe8, 0xe7, 0x90, 0x27, 0x41, 0x40, 0x03, 0xe1, 0xca, 0x6e, 0xf3, 0x69, 0x4a, 0x4b,
	0x24, 0xa5, 0x61, 0x70, 0x22, 0xee, 0x21, 0x96, 0xf4, 0xe8, 0x29, 0x54, 0xc4, 0xc2, 0x74, 0x08,
	0xb3, 0x5c, 0x4f, 0xf8, 0x59, 0xc2, 0x65, 0x71, 0xd6, 0x11, 0x47, 0xfc, 0x86, 0x8e, 0xdd, 0x30,
	0x74, 0xfd, 0x9b, 0x7b, 0x57, 0xb2, 0x2b, 0x6f, 0xa8, 0x62, 0x51, 0x68, 0x7c, 0x01, 0x8f, 0x27,
	0x56, 0x10, 0x12, 0xf3, 0xda, 0x72, 0x3d, 0x12, 0x5f, 0xf5, 0xfc, 0x6a, 0x41, 0x8f, 0x04, 0xdf,
	0x6b, 0xc1, 0xa6, 0x80, 0x19, 0x43, 0x29, 0xf6, 0x03, 0x95, 0x61, 0x7b, 0x34, 0xf8, 0x62, 0x70,
	0xfe, 0xab, 0x41, 0x75, 0x0b, 0xed, 0x43, 0xb5, 0x37, 0x78, 0xd3, 0x3a, 0xeb, 0x75, 0xcc, 0x16,
	0xee, 0x8e, 0xfa, 0xc6, 0xe0, 0xb2, 0xaa, 0x21, 0x04, 0xbb, 0xfd, 0xde, 0x70, 0xd8, 0x1b, 0x74,
	0xcd, 0x4e, 0xaf, 0x6b, 0x0c, 0x2f, 0xab, 0x19, 0xf4, 0x18, 0xf6, 0xe4, 0xda, 0xec, 0xf7, 0x86,
	0xfd, 0xd6, 0x65, 0xfb, 0xb4, 0x9a, 0xe5, 0xec, 0x83, 0xf3, 0x8e, 0x61, 0x5e, 0xb4, 0xf0, 0xd0,
	0x30, 0x0d, 0x8c, 0xcf, 0x71, 0x35, 0xa7, 0xff, 0x53, 0x83, 0x22, 0xcf, 0xcb, 0x01, 0x57, 0xf7,
	0x59, 0x3a, 0x8d, 0xb5, 0x55, 0x69, 0x3c, 0x9b, 0xc4, 0xa8, 0x09, 0x79, 0xfb, 0xd6, 0xf5, 0x1c,
	0x75, 0xcf, 0x0f, 0x1f, 0x32, 0x72, 0x3d, 0x8d, 0x36, 0xa7, 0xc1, 0x92, 0xb4, 0x7e, 0x01, 0x79,
	0xb1, 0x9f, 0x7b, 0x1f, 0x5f, 0x7d, 0x8b, 0xfb, 0x18, 0xdd, 0x46, 0xbd, 0x0b, 0xd5, 0xb6, 0x15,
	0x9e, 0x51, 0xfa, 0xf5, 0x74, 0x82, 0xc9, 0x6f, 0xa7, 0x3c, 0x46, 0xc9, 0xaa, 0x9f, 0x5d, 0x57,
	0x50, 0x0b, 0x76, 0x13, 0x82, 0x26, 0xde, 0x3b, 0xf4, 0x12, 0x0a, 0xa1, 0x48, 0x36, 0x05, 0xcd,
	0x77, 0x16, 0xe4, 0x22, 0x56, 0x64, 0xfa, 0x10, 0x0e, 0xdb, 0x56, 0x38, 0x9a, 0x78, 0xd4, 0x72,
	0x2e, 0x03, 0x72, 0x0f, 0x5c, 0x6c, 0x57, 0x89, 0x05, 0x84, 0x98, 0x3e, 0xbf, 0xaa, 0xd2, 0xb4,
	0x83, 0xf9, 0xa8, 0xe1, 0x22, 0x27, 0xe4, 0x2b, 0xbd, 0x0f, 0xf5, 0x05, 0x42, 0x37, 0xb2, 0xf1,
	0x4b, 0x78, 0xd2, 0xb6, 0xc2, 0x0e, 0xfd, 0x9d, 0xbf, 0xc8, 0xca, 0x97, 0x90, 0xe3, 0xdd, 0x67,
	0x9d, 0xee, 0x25, 0x08, 0xf5, 0x3f, 0x6a, 0xc2, 0xef, 0xf9, 0x32, 0x37, 0x31, 0x72, 0x16, 0xa8,
	0xcc, 0x9a, 0x40, 0x79, 0x50, 0x3a, 0xf1, 0xe8, 0x55, 0xfb, 0x76, 0xea, 0x7f, 0xbd, 0x59, 0xe3,
	0x3f, 0x80, 0x02, 0xbd, 0xbe, 0x0e, 0x09, 0x53, 0x23, 0x87, 0xda, 0xf1, 0x64, 0x8d, 0x0b, 0x7d,
	0x05, 0x8b, 0xb5, 0xde, 0x86, 0xfd, 0x38, 0x2c, 0x5c, 0x6d, 0x84, 0xde, 0x8f, 0x15, 0xed, 0x5c,
	0x4f, 0x63, 0xfb, 0x94, 0x10, 0x03, 0x50, 0x4a, 0xc8, 0x46, 0x31, 0x7d, 0x03, 0x07, 0x29, 0xfc,
	0x23, 0x6b, 0x7e, 0x09, 0xe5, 0xe4, 0x24, 0xb1, 0x06, 0x16, 0x10, 0xc4, 0x43, 0x84, 0x3e, 0x11,
	0x77, 0x2b, 0x92, 0xbb, 0x61, 0x2c, 0x23, 0x40, 0x32, 0xeb, 0x00, 0xd2, 0x9f, 0xf1, 0x24, 0x89,
	0xeb, 0x46, 0x77, 0xfa, 0x2b, 0xf8, 0xc0, 0x10, 0x73, 0x9b, 0x4b, 0xfd, 0xb6, 0x65, 0xdf, 0xc6,
	0xb8, 0x7c, 0x0e, 0x3b, 0x96, 0x68, 0xba, 0xdf, 0x02, 0x99, 0x8a, 0xe4, 0x50, 0xd8, 0xfc, 0x5b,
	0x83, 0xfd, 0x59, 0xd9, 0x6b, 0xb5, 0xb7, 0x93, 0xd9, 0xf6, 0xf6, 0x62, 0x56, 0xe1, 0x3c, 0x81,
	0x9b, 0x74, 0x3a, 0xfd, 0xd3, 0x85, 0x8d, 0x25, 0xd1, 0x42, 0xb0, 0x31, 0x1c, 0x9d, 0xf1, 0xb6,
	0xb2, 0x07, 0xe5, 0xd1, 0x60, 0x38, 0xba, 0xb8, 0x38, 0xc7, 0x97, 0x46, 0xa7, 0x9a, 0xd1, 0xbf,
	0xd1, 0xe0, 0x71, 0x1a, 0x38, 0x1e, 0xfc, 0x5f, 0xa4, 0x82, 0xaf, 0xaf, 0x36, 0x3f, 0xce, 0x83,
	0x26, 0x14, 0x02, 0x31, 0xe1, 0xa8, 0x4c, 0x48, 0x35, 0x9a, 0xe4, 0x0c, 0x84, 0x15, 0xa5, 0xfe,
	0x27, 0x0d, 0x6a, 0x29, 0xa1, 0x84, 0xfd, 0xdf, 0x62, 0xb8, 0x91, 0x49, 0x97, 0x70, 0x30, 0xc7,
	0xa2, 0xf7, 0x04, 0x47, 0xff, 0x5b, 0x06, 0x76, 0x25, 0x41, 0x9c, 0xa2, 0x2f, 0xa0, 0x20, 0x8d,
	0x55, 0xe2, 0xf6, 0xe7, 0x1a, 0xa7, 0x68, 0xd0, 0x47, 0x1c, 0x0c, 0x9b, 0x4c, 0x98, 0x69, 0x73,
	0xf1, 0x8e, 0xf0, 0xa8, 0xc8, 0xfd, 0xe5, 0x87, 0x42, 0xa5, 0x83, 0x5e, 0xc1, 0x01, 0xa3, 0xcc,
	0xf2, 0x4c, 0xf9, 0xc6, 0x10, 0xed, 0xdf, 0xa6, 0x53, 0x9f, 0xa9, 0x67, 0xd4, 0x63, 0xf1, 0xb5,
	0xc7, 0x3f, 0xf2, 0xfa, 0xda, 0xe6, 0x9f, 0xe6, 0x32, 0xc9, 0x77, 0x59, 0x4e, 0x14, 0xc9, 0x14,
	0x93, 0x7c, 0xa1, 0xfd, 0x0c, 0x40, 0x58, 0x6b, 0xba, 0xfe, 0x35, 0x55, 0xef, 0x8b, 0xf4, 0xd5,
	0xe7, 0x9b, 0x9e, 0x7f, 0x4d, 0x71, 0xe9, 0x2a, 0x5a, 0xa2, 0x1f, 0xc0, 0x2e, 0x73, 0xc7, 0x84,
	0x8f, 0xab, 0x63, 0xd7, 0xf3, 0xdc, 0xb0, 0x56, 0x10, 0x4a, 0x76, 0xd4, 0x69, 0x5f, 0x1c, 0xea,
	0xcf, 0xa1, 0x14, 0xb3, 0xa3, 0xef, 0x42, 0x51, 0xe9, 0x72, 0xd4, 0x38, 0xb1, 0x2d, 0x05, 0x3a,
	0x7a, 0x35, 0x42, 0xd5, 0xa5, 0x3e, 0x47, 0x3c, 0xd4, 0xff, 0x9c, 0x81, 0x4a, 0x0c, 0x34, 0x8f,
	0xda, 0x27, 0xa9, 0xa8, 0x7d, 0xb8, 0x20, 0x6a, 0xef, 0x9f, 0xcd, 0x3c, 0x46, 0x32, 0x38, 0xa6,
	0x62, 0x95, 0x4f, 0xcb, 0x8a, 0x3c, 0x54, 0xe3, 0xbf, 0x01, 0x7b, 0x24, 0xd2, 0x69, 0x72, 0x65,
	0xa1, 0x9a, 0xb7, 0x0f, 0x97, 0x18, 0x16, 0xe2, 0x5d, 0x32, 0xb3, 0x47, 0x3f, 0x85, 0x92, 0x6d,
	0x85, 0xa6, 0xac, 0x35, 0xf9, 0xe5, 0x95, 0xba, 0x68, 0x5b, 0xa1, 0xa8, 0x16, 0xfa, 0x5f, 0xb3,
	0xb0, 0x97, 0xf2, 0x98, 0x3f, 0xbb, 0xa4, 0xec, 0xb8, 0x9c, 0xc5, 0xfb, 0xd9, 0x5a, 0x97, 0x49,
	0xd7, 0xba, 0x4f, 0xa3, 0x5a, 0x97, 0x15, 0xb5, 0xee, 0x87, 0x4b, 0x91, 0x5d, 0x5d, 0xe6, 0x72,
	0x0f, 0x07, 0xfa, 0xcf, 0x20, 0x1f, 0x32, 0xeb, 0x86, 0x08, 0x0f, 0x77, 0x9b, 0x3f, 0x5a, 0xae,
	0x41, 0x06, 0x65, 0xc8, 0x19, 0xb0, 0xe4, 0xd3, 0xfd, 0x64, 0x9d, 0x7c, 0x04, 0x3b, 0xaa, 0x4e,
	0xaa, 0x89, 0x79, 0x8b, 0x0f, 0xd7, 0x51, 0xb5, 0x6c, 0x9f, 0xf7, 0xfb, 0xad, 0x41, 0xa7, 0xaa,
	0x71, 0xba, 0xe8, 0xb0, 0x37, 0xb8, 0x18, 0xf1, 0x21, 0xfc, 0x03, 0x78, 0xd4, 0x31, 0x5a, 0x9d,
	0xb3, 0xde, 0xc0, 0x30, 0x8d, 0xb7, 0x6d, 0xc3, 0xe8, 0x18, 0x9d, 0x6a, 0x96, 0x17, 0x56, 0xe3,
	0xad, 0xd1, 0x36, 0x5f, 0xb7, 0x7a, 0x67, 0x46, 0xa7, 0x9a, 0xd3, 0x7b, 0x50, 0x4e, 0x58, 0x91,
	0xd4, 0x38, 0xbc, 0x6c, 0x75, 0x8d, 0xea, 0x16, 0x02, 0x28, 0x7c, 0x39, 0x32, 0x46, 0x06, 0x57,
	0xb4, 0x03, 0x25, 0xce, 0x3e, 0xba, 0xec, 0x0d, 0xba, 0xd5, 0x0c, 0xaa, 0x40, 0xf1, 0x75, 0x6f,
	0xd0, 0x1b, 0x9e, 0x72, 0xd9, 0xcd, 0x7f, 0xe4, 0x00, 0x78, 0x0c, 0x49, 0x70, 0xe7, 0xda, 0x04,
	0x9d, 0x42, 0x41, 0xce, 0xae, 0xe8, 0xc9, 0x83, 0x38, 0xcf, 0x4c, 0xc7, 0xf5, 0xc3, 0x85, 0xdf,
	0x27, 0xde, 0x3b, 0x7d, 0x0b, 0x79, 0x80, 0x1e, 0x4e, 0x9b, 0xe8, 0xe3, 0x07, 0x5c, 0x0b, 0xe7,
	0xdc, 0xfa, 0xf1, 0x5a, 0xb4, 0x52, 0xdb, 0x1b, 0x80, 0xfb, 0xf9, 0x07, 0xe9, 0x0b, 0x38, 0x13,
	0x93, 0x40, 0xfd, 0x68, 0x29, 0x8d, 0x90, 0x7a, 0xac, 0xa1, 0x00, 0xf6, 0xe7, 0x0d, 0xa4, 0xe8,
	0xc5, 0x03, 0xee, 0x25, 0xb3, 0x70, 0xfd, 0xe3, 0x35, 0xa9, 0xa5, 0x2f, 0x6f, 0xa1, 0x92, 0xfc,
	0x8c, 0x9e, 0x2d, 0xe5, 0x8e, 0x74, 0x3c, 0x59, 0x48, 0xa5, 0xe4, 0xfe, 0x44, 0x4b, 0x4a, 0x16,
	0x38, 0x2d, 0x96, 0x9c, 0x44, 0x6a, 0x0d, 0xc9, 0xcd, 0x7f, 0x69, 0xe9, 0x19, 0x29, 0xca, 0xa8,
	0x5f, 0xc3, 0x5e, 0x97, 0xa8, 0xd6, 0xa1, 0x8a, 0xd3, 0x47, 0xcb, 0x5a, 0x5a, 0xa4, 0xf5, 0xe9,
	0x72, 0x22, 0x09, 0x95, 0x05, 0x7b, 0xc3, 0x94, 0xf0, 0xe7, 0x4b, 0xfb, 0x65, 0xdc, 0xf7, 0xeb,
	0xcf, 0x56, 0xd2, 0x09, 0x15, 0xcd, 0xaf, 0xe2, 0x96, 0x1a, 0x79, 0xd4, 0x85, 0x6d, 0x75, 0x82,
	0xe6, 0x56, 0xd3, 0xd8, 0x85, 0xfa, 0x82, 0xaf, 0x0a, 0xb4, 0x93, 0xe7, 0xf0, 0xcc, 0xa6, 0xe3,
	0xc6, 0x0d, 0xa5, 0x37, 0x1e, 0x69, 0x38, 0xe4, 0x8e, 0x51, 0xea, 0x85, 0x8a, 0xc9, 0x73, 0xaf,
	0x14, 0xe3, 0x55, 0x41, 0xfc, 0x0b, 0xfa, 0xea, 0x7f, 0x01, 0x00, 0x00, 0xff, 0xff, 0x0f, 0x1f,
	0x57, 0x28, 0x2b, 0x15, 0x00, 0x00,
}
